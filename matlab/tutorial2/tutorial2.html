
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>tutorial2</title><meta name="generator" content="MATLAB 7.14"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2013-02-01"><meta name="DC.source" content="tutorial2.m"><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, tt, code { font-size:12px; }
pre { margin:0px 0px 20px; }
pre.error { color:red; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }

  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#2">2. Frequency analysis</a></li><li><a href="#10">Automatic classification</a></li></ul></div><pre class="codeinput"><span class="keyword">function</span> tutorial2()
</pre><h2>2. Frequency analysis<a name="2"></a></h2><p>This tutorial covers basic frequency analysis of the EEG signal. The recording that is used is of a subject performing the SSVEP (steady-state visual evoked potential) paradigm. In simplest terms: when we look at a light that is flashing on and off at a certain frequency <span class="MathJax_Preview"><img src="tutorial2_eq85998.png" alt="$f$"></span><script type="math/tex">f</script>, the neurons in our visual cortex will resonate at the same frequency (plus the harmonics <span class="MathJax_Preview"><img src="tutorial2_eq24448.png" alt="$1f$"></span><script type="math/tex">1f</script>, <span class="MathJax_Preview"><img src="tutorial2_eq06212.png" alt="$2f$"></span><script type="math/tex">2f</script>, <span class="MathJax_Preview"><img src="tutorial2_eq35739.png" alt="$3f$"></span><script type="math/tex">3f</script>, ...) This phenomenon can be used to create a brain-computer interface. Different options are presented on the screen, each flashing at a different frequency. By determining the frequency at which the visual cortex is resonating, the option that is attended can be distinguished from the rest.</p><p>In the current case, the subject is a witness in a cluedo murder mystery. He will try to communicate the murderer, weapon and location. The options available for selection, along with their corresponding frequency are as follows:</p><pre>   Murderer:
       Colonel Mustard (8Hz)
       Miss Scarlett (10Hz)
       Professor Plum (12Hz)
       Reverend Green (15Hz)</pre><pre>   Weapon:
       Axe (8Hz)
       Poison (10Hz)
       Revolver (12Hz)
       Rope (15Hz)</pre><pre>   Location:
       Billiard Room (8Hz)
       Dining Room (10Hz)
       Kitchen (12Hz)
       Library (15Hz)</pre><p>The data is located on my public dropbox account. Again, running the code below will download the data, which will take some time depending on the speed of your internet connection.</p><p><b>NOTE:</b> The data used in this tutorial is EEG data that has been bandpass filtered with a 3rd order Butterworth filter with a passband of 1.0-40 Hz. When performing analysis on other data, you might have to filter it yourself. Bandpass filtering is covered in the 3rd tutorial.</p><pre class="codeinput">urlwrite(<span class="string">'http://dl.dropbox.com/u/79303435/tutorial2-01.mat?dl=1'</span>, <span class="string">'tutorial2-01.mat'</span>);
</pre><p>Using <tt>load</tt> to load the Matlab file and printing the variables stored within:</p><pre class="codeinput">m = load(<span class="string">'tutorial2-01.mat'</span>);
disp(<span class="string">'Fields of m:'</span>);
disp(fields(m));
</pre><pre class="codeoutput">Fields of m:
    'Murder_filteredEEG'
    'Weapon_filteredEEG'
    'Room_filteredEEG'

</pre><p>The three variables of interest are <tt>Murder_filteredEEG</tt>, <tt>Weapon_filteredEEG</tt> and <tt>Room_filteredEEG</tt></p><pre class="codeinput">murder_EEG = m.Murder_filteredEEG;
weapon_EEG = m.Weapon_filteredEEG;
room_EEG = m.Room_filteredEEG;

disp(<span class="string">'Shape of murder_EEG:'</span>); disp(size(murder_EEG));
disp(<span class="string">'Shape of weapon_EEG:'</span>); disp(size(weapon_EEG));
disp(<span class="string">'Shape of room_EEG:'</span>); disp(size(room_EEG));
</pre><pre class="codeoutput">Shape of murder_EEG:
          14        2560

Shape of weapon_EEG:
          14        2560

Shape of room_EEG:
          14        2560

</pre><p>The data was recorded using the <a href="http://www.emotiv.com">Emotiv EPOC</a> device. It has 14 channels and a sample rate of 128Hz:</p><pre class="codeinput">nchannels = size(murder_EEG, 1);
nsamples = size(murder_EEG, 2);
sample_rate = 128;

fprintf(<span class="string">'Duration of recordings: %.1f seconds\n'</span>, nsamples / sample_rate);
</pre><pre class="codeoutput">Duration of recordings: 20.0 seconds
</pre><p>The subject was looking for 20 seconds at one of the four selection options. If we plot the PSD (power spectral density) of the channels on the visual cortex, there should be a distinctive peak at the frequency of the attended option. The algorithm to calculate a PSD is provided by the function <tt>pwelch</tt>:</p><pre class="codeinput">help <span class="string">pwelch</span>;
</pre><pre class="codeoutput"> PWELCH Power Spectral Density estimate via Welch's method.
    Pxx = PWELCH(X) returns the Power Spectral Density (PSD) estimate, 
    Pxx, of a discrete-time signal vector X using Welch's averaged, 
    modified periodogram method.  By default, X is divided into eight
    sections with 50% overlap, each section is windowed with a Hamming
    window and eight modified periodograms are computed and averaged.
 
    If the length of X is such that it cannot be divided exactly into
    eight sections with 50% overlap, X will be truncated accordingly. 
 
    Pxx is the distribution of power per unit frequency. For real signals,
    PWELCH returns the one-sided PSD by default; for complex signals, it
    returns the two-sided PSD.  Note that a one-sided PSD contains the
    total power of the input signal.
 
    Note also that the default window (Hamming) has a 42.5 dB sidelobe
    attenuation. This may mask spectral content below this value (relative
    to the peak spectral content). Choosing different windows will enable
    you to make tradeoffs between resolution (e.g., using a rectangular
    window) and sidelobe attenuation (e.g., using a Hann window). See
    WinTool for more details.
 
    Pxx = PWELCH(X,WINDOW), when WINDOW is a vector, divides X into
    overlapping sections of length equal to the length of WINDOW, and then
    windows each section with the vector specified in WINDOW.  If WINDOW is
    an integer, X is divided into sections of length equal to that integer
    value, and a Hamming window of equal length is used.  If the length of 
    X is such that it cannot be divided exactly into integer number of 
    sections with 50% overlap, X will be truncated accordingly.  If WINDOW 
    is omitted or specified as empty, a default window is used to obtain 
    eight sections of X.
 
    Pxx = PWELCH(X,WINDOW,NOVERLAP) uses NOVERLAP samples of overlap from
    section to section.  NOVERLAP must be an integer smaller than the WINDOW
    if WINDOW is an integer.  NOVERLAP must be an integer smaller than the
    length of WINDOW if WINDOW is a vector.  If NOVERLAP is omitted or
    specified as empty, the default value is used to obtain a 50% overlap.
 
    [Pxx,W] = PWELCH(X,WINDOW,NOVERLAP,NFFT) specifies the number of FFT
    points used to calculate the PSD estimate.  For real X, Pxx has length
    (NFFT/2+1) if NFFT is even, and (NFFT+1)/2 if NFFT is odd.  For complex
    X, Pxx always has length NFFT.  If NFFT is specified as empty, the 
    default NFFT -the maximum of 256 or the next power of two
    greater than the length of each section of X- is used.
 
    Note that if NFFT is greater than the segment the data is zero-padded.
    If NFFT is less than the segment, the segment is "wrapped" (using
    DATAWRAP) to make the length equal to NFFT. This produces the correct
    FFT when NFFT &lt; L, L being signal or segment length.                       
 
    W is the vector of normalized frequencies at which the PSD is
    estimated.  W has units of rad/sample.  For real signals, W spans the
    interval [0,Pi] when NFFT is even and [0,Pi) when NFFT is odd.  For
    complex signals, W always spans the interval [0,2*Pi).
 
    [Pxx,W] = PWELCH(X,WINDOW,NOVERLAP,W) where W is a vector of 
    normalized frequencies (with 2 or more elements) computes the 
    PSD at those frequencies using the Goertzel algorithm. In this 
    case a two sided PSD is returned. The specified frequencies in W are 
    rounded to the nearest DFT bin commensurate with the signal's 
    resolution.     
 
    [Pxx,F] = PWELCH(X,WINDOW,NOVERLAP,NFFT,Fs) returns a PSD computed as
    a function of physical frequency (Hz).  Fs is the sampling frequency
    specified in Hz.  If Fs is empty, it defaults to 1 Hz.
 
    F is the vector of frequencies at which the PSD is estimated and has
    units of Hz.  For real signals, F spans the interval [0,Fs/2] when NFFT
    is even and [0,Fs/2) when NFFT is odd.  For complex signals, F always
    spans the interval [0,Fs).
 
    [Pxx,F] = PWELCH(X,WINDOW,NOVERLAP,F,Fs) where F is a vector of 
    frequencies in Hz (with 2 or more elements)  computes the PSD at 
    those frequencies using the Goertzel algorithm. In this case a two
    sided PSD is returned.  The specified frequencies in F are rounded to 
    the nearest DFT bin commensurate with the signal's resolution. 
 
    [...] = PWELCH(...,'twosided') returns a two-sided PSD of a real signal
    X. In this case, Pxx will have length NFFT and will be computed  over
    the interval [0,2*Pi) if Fs is not specified and over the interval
    [0,Fs) if Fs is specified.  Alternatively, the string 'twosided' can be
    replaced with the string 'onesided' for a real signal X.  This would
    result in the default behavior.  The string 'twosided' or 'onesided'
    may be placed in any position in the input argument list after NOVERLAP. 
 
    PWELCH(...) with no output arguments by default plots the PSD
    estimate in dB per unit frequency in the current figure window.
 
    EXAMPLE:
       Fs = 1000;   t = 0:1/Fs:.296;
       x = cos(2*pi*t*200)+randn(size(t));  % A cosine of 200Hz plus noise
       pwelch(x,[],[],[],Fs,'twosided'); % Uses default window, overlap &amp; NFFT. 
  
    See also PERIODOGRAM, PCOV, PMCOV, PBURG, PYULEAR, PEIG, PMTM, PMUSIC,
    SPECTRUM, DSPDATA.

    Reference page in Help browser
       doc pwelch

</pre><p>Below is some code that calculates the PSD for some channels of the murderer EEG block:</p><pre class="codeinput"><span class="comment">% These channels are roughly in the area covering the visual cortex</span>
channels_of_interest = [1, 2, 3, 12, 13, 14];

<span class="comment">% Create a new figure</span>
figure(<span class="string">'Position'</span>, [100, 100, 1000, 500]);

<span class="comment">% Draw the PSD of each channel of interest</span>
<span class="keyword">for</span> i = 1:length(channels_of_interest)
    ch = channels_of_interest(i);

    <span class="comment">% The main plot is devided into 6 subplots: one for each channel</span>
    <span class="comment">% They are layed out in a grid: 2 rows and 3 columns</span>
    subplot(2, 3, i);

    <span class="comment">% Calculate the PSD</span>
    [murder_PSD, freqs] = pwelch(murder_EEG(ch,:), nsamples, [], [], sample_rate);

    <span class="comment">% Plot the PSD</span>
    plot(freqs, murder_PSD);

    <span class="comment">% Each graph should have the same scale, otherwise we cannot compare them</span>
    xlim([0, 40]);
    ylim([0, 60]);

    <span class="comment">% Add some decoration</span>
    grid();
    xlabel(<span class="string">'Frequency (Hz)'</span>);
    ylabel(<span class="string">'PSD (dB)'</span>);
    title(sprintf(<span class="string">'Channel %d'</span>, ch));
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="tutorial2_01.png" alt=""> <p>The EEG recording made by the Emotiv EPOC is noisy: there are many peaks. Still, the peak at 10Hz is strongest as can be observed at channels 1 and 14. Therefore the conclusion is that the murderer is Miss Scarlett.</p><h2>Automatic classification<a name="10"></a></h2><p>A common approach to automatically determine the frequency that is present most strongly is <a href="http://en.wikipedia.org/wiki/Canonical_correlation">Canonical Correlation Analysis (CCA)</a> [1]. The idea is that an EEG recording of someone looking at a SSVEP stimulus with frequency <span class="MathJax_Preview"><img src="tutorial2_eq85998.png" alt="$f$"></span><script type="math/tex">f</script>, will be highly correlated with a generated sine wave with the same frequency. More so than a generated sine wave with a different frequency. Under the condition that the EEG signal and the generated sine are in phase (e.g. the waveforms 'line up'). This condition is problematic, as we have no guarantee that this will be the case. To counter the phase shift, we correlate the EEG signal with both a sine and a cosine wave, following the same logic employed by the Fourier transform. If the sine wave correlates poorly, the cosine will correlate strongly and vice versa, as long as the frequencies match.</p><p>Simple correlation analysis only compares two vectors, lets call them <span class="MathJax_Preview"><img src="tutorial2_eq43551.png" alt="$x$"></span><script type="math/tex">x</script> and <span class="MathJax_Preview"><img src="tutorial2_eq44020.png" alt="$y$"></span><script type="math/tex">y</script>. For example a single EEG channel and an artificial signal of the same length. In our case we have multiple EEG channels, so vector <span class="MathJax_Preview"><img src="tutorial2_eq43551.png" alt="$x$"></span><script type="math/tex">x</script> becomes a matrix <span class="MathJax_Preview"><img src="tutorial2_eq03598.png" alt="$X$"></span><script type="math/tex">X</script> with samples along the rows and channels in the columns. We are testing this signal against multiple sine and cosine waves, generated with frequence <span class="MathJax_Preview"><img src="tutorial2_eq85998.png" alt="$f$"></span><script type="math/tex">f</script> and also some harmonics of <span class="MathJax_Preview"><img src="tutorial2_eq85998.png" alt="$f$"></span><script type="math/tex">f</script> (<span class="MathJax_Preview"><img src="tutorial2_eq06212.png" alt="$2f$"></span><script type="math/tex">2f</script> and <span class="MathJax_Preview"><img src="tutorial2_eq35739.png" alt="$3f$"></span><script type="math/tex">3f</script> in this case). So <span class="MathJax_Preview"><img src="tutorial2_eq44020.png" alt="$y$"></span><script type="math/tex">y</script> becomes a matrix <span class="MathJax_Preview"><img src="tutorial2_eq17977.png" alt="$Y$"></span><script type="math/tex">Y</script> with the generated samples in the rows and each column containing either a sine or cosine generated with some frequency.</p><p>The CCA procedure can be seen as a way to calculate the correlation between two sets of vectors simultaniously, a set of vectors being the same as a matrix. It does so be calculating a vector <span class="MathJax_Preview"><img src="tutorial2_eq79048.png" alt="$u_0$"></span><script type="math/tex">u_0</script>, which is a linear combination of the columns of <span class="MathJax_Preview"><img src="tutorial2_eq03598.png" alt="$X$"></span><script type="math/tex">X</script> and a vector <span class="MathJax_Preview"><img src="tutorial2_eq60913.png" alt="$v_0$"></span><script type="math/tex">v_0</script>, which is a linear combination of the columns of <span class="MathJax_Preview"><img src="tutorial2_eq17977.png" alt="$Y$"></span><script type="math/tex">Y</script>, in such a way that the correlation coefficient <span class="MathJax_Preview"><img src="tutorial2_eq20099.png" alt="$\rho$"></span><script type="math/tex">\rho</script> between <span class="MathJax_Preview"><img src="tutorial2_eq79048.png" alt="$u_0$"></span><script type="math/tex">u_0</script> and <span class="MathJax_Preview"><img src="tutorial2_eq60913.png" alt="$v_0$"></span><script type="math/tex">v_0</script> is maximal. It then goes on to calculate more vectors <span class="MathJax_Preview"><img src="tutorial2_eq16202.png" alt="$u_1$"></span><script type="math/tex">u_1</script> and <span class="MathJax_Preview"><img src="tutorial2_eq34998.png" alt="$v_1$"></span><script type="math/tex">v_1</script> that are uncorrelated with <span class="MathJax_Preview"><img src="tutorial2_eq79048.png" alt="$u_0$"></span><script type="math/tex">u_0</script> and <span class="MathJax_Preview"><img src="tutorial2_eq60913.png" alt="$v_0$"></span><script type="math/tex">v_0</script> and maximally correlated with each other. In our case however, we are only interested in the correlation between <span class="MathJax_Preview"><img src="tutorial2_eq79048.png" alt="$u_0$"></span><script type="math/tex">u_0</script> and <span class="MathJax_Preview"><img src="tutorial2_eq60913.png" alt="$v_0$"></span><script type="math/tex">v_0</script>.</p><p>The task of our classifier is what we did manually before: to pick, out of the frequencies of all the stimuli on the screen, the one that best corresponds to what is present in the EEG signal. Therefore, for each frequency, we calculate a score for that frequency by performing CCA between the EEG signal and a matrix of generated sine/cosine waves with the frequency and its harmonics. Finally we pick the frequency with the highest score.</p><p>[1] Frequency recognition based on canonical correlation analysis for SSVEP-based BCIs. Lin, Zhonglin / Zhang, Changshui / Wu, Wei / Gao, Xiaorong, <i>IEEE transactions on bio-medical engineering</i>, 53 (12 Pt 2), p.2610-2614, Dec 2006, <a href="http://www.ncbi.nlm.nih.gov/pubmed/17152442">http://www.ncbi.nlm.nih.gov/pubmed/17152442</a></p><p>The CCA algorithm is provided by the matlab <tt>canoncorr</tt> function:</p><pre class="codeinput">help <span class="string">canoncorr</span>;
</pre><pre class="codeoutput"> CANONCORR Canonical correlation analysis.
    [A,B] = CANONCORR(X,Y) computes the sample canonical coefficients for
    the N-by-P1 and N-by-P2 data matrices X and Y.  X and Y must have the
    same number of observations (rows) but can have different numbers of
    variables (cols).  A and B are P1-by-D and P2-by-D matrices, where D =
    min(rank(X),rank(Y)).  The jth columns of A and B contain the canonical
    coefficients, i.e. the linear combination of variables making up the
    jth canonical variable for X and Y, respectively.  Columns of A and B
    are scaled to make COV(U) and COV(V) (see below) the identity matrix.
    If X or Y are less than full rank, CANONCORR gives a warning and
    returns zeros in the rows of A or B corresponding to dependent columns
    of X or Y.
 
    [A,B,R] = CANONCORR(X,Y) returns the 1-by-D vector R containing the
    sample canonical correlations.  The jth element of R is the correlation
    between the jth columns of U and V (see below).
 
    [A,B,R,U,V] = CANONCORR(X,Y) returns the canonical variables, also
    known as scores, in the N-by-D matrices U and V.  U and V are computed
    as
 
       U = (X - repmat(mean(X),N,1))*A and
       V = (Y - repmat(mean(Y),N,1))*B.
 
    [A,B,R,U,V,STATS] = CANONCORR(X,Y) returns a structure containing
    information relating to the sequence of D null hypotheses H0_K, that
    the (K+1)st through Dth correlations are all zero, for K = 0:(D-1).
    STATS contains eight fields, each a 1-by-D vector with elements
    corresponding to values of K:
 
       Wilks:    Wilks' lambda (likelihood ratio) statistic
       chisq:    Bartlett's approximate chi-squared statistic for H0_K,
                 with Lawley's modification
       pChisq:   the right-tail significance level for CHISQ
       F:        Rao's approximate F statistic for H0_K
       pF:       the right-tail significance level for F
       df1:      the degrees of freedom for the chi-squared statistic,
                 also the numerator degrees of freedom for the F statistic
       df2:      the denominator degrees of freedom for the F statistic
 
    Example:
 
       load carbig;
       X = [Displacement Horsepower Weight Acceleration MPG];
       nans = sum(isnan(X),2) &gt; 0;
       [A B r U V] = canoncorr(X(~nans,1:3), X(~nans,4:5));
 
       plot(U(:,1),V(:,1),'.');
       xlabel('0.0025*Disp + 0.020*HP - 0.000025*Wgt');
       ylabel('-0.17*Accel + -0.092*MPG')
 
    See also PRINCOMP, MANOVA1.

    Reference page in Help browser
       doc canoncorr

</pre><p>Below is a function that implements the classifier:</p><pre class="codeinput"><span class="keyword">function</span> winner = ssvep_classifier(EEG, frequencies)
<span class="comment">%     SSVEP classifier based on Canonical Correlation Analysis (CCA).</span>
<span class="comment">%     Given a list of frequencies, this function will return the frequency</span>
<span class="comment">%     that is present the most strongly in some given EEG signal.</span>

    <span class="comment">% The matrix X is our EEG signal, but we transpose it so</span>
    <span class="comment">% observations (=samples) are on the rows and variables (=channels)</span>
    <span class="comment">% are on the columns.</span>
    X = EEG';

    <span class="comment">% Keep track of the score for each frequency</span>
    scores = [];

    <span class="comment">% Calculate a timeline in seconds, so we can construct</span>
    <span class="comment">% sine/cosine waves with the correct frequencies</span>
    time = (1:nsamples) / sample_rate;

    <span class="comment">% Calculate sines/cosines for all possible frequencies</span>
    <span class="keyword">for</span> frequency = frequencies

        <span class="comment">% Calculate this part only once</span>
        y = 2 * pi * frequency * time;

        <span class="comment">% Construct the matrix Y containing the base frequency and 2 harmonics</span>
        Y = [sin(y); cos(y); sin(2*y); cos(2*y); sin(3*y); cos(3*y)]';

        <span class="comment">% Perform canonical correlation, we only care about the</span>
        <span class="comment">% coefficients:</span>
        [~, ~, R] = canoncorr(X,Y);

        <span class="comment">% Note the highest (= first) coefficient as the final score for</span>
        <span class="comment">% this frequency</span>
        scores = [scores R(1)];
    <span class="keyword">end</span>

    <span class="comment">% Return the frequency with the highest score</span>
    [~, winner_index] = max(scores);
    winner = frequencies(winner_index);
<span class="keyword">end</span>
</pre><p>Putting the classifier to work, lets solve the murder completely:</p><pre class="codeinput">fprintf(<span class="string">'Murderer frequency: %d Hz.\n'</span>, ssvep_classifier(murder_EEG, [8, 10, 12, 15]));
fprintf(<span class="string">'Weapon frequency:   %d Hz.\n'</span>, ssvep_classifier(weapon_EEG, [8, 10, 12, 15]));
fprintf(<span class="string">'Room: frequency:    %d Hz.\n'</span>, ssvep_classifier(room_EEG, [8, 10, 12, 15]));
</pre><pre class="codeoutput">Murderer frequency: 10 Hz.
Weapon frequency:   15 Hz.
Room: frequency:    12 Hz.
</pre><p>Looking at the table at the beginning of this tutorial, this means Miss Scarlett was the murderer, using a rope in the kitchen.</p><pre class="codeinput"><span class="keyword">end</span>
</pre><p class="footer"><br>
      Published with MATLAB&reg; 7.14<br></p></div><!--
##### SOURCE BEGIN #####
function tutorial2()

%% 2. Frequency analysis
%
% This tutorial covers basic frequency analysis of the EEG signal. The
% recording that is used is of a subject performing the SSVEP (steady-state
% visual evoked potential) paradigm. In simplest terms: when we look at a
% light that is flashing on and off at a certain frequency $f$, the neurons
% in our visual cortex will resonate at the same frequency (plus the
% harmonics $1f$, $2f$, $3f$, ...) This phenomenon can be used to create a
% brain-computer interface. Different options are presented on the screen,
% each flashing at a different frequency. By determining the frequency at
% which the visual cortex is resonating, the option that is attended can be
% distinguished from the rest.
%
% In the current case, the subject is a witness in a cluedo murder mystery.
% He will try to communicate the murderer, weapon and location. The options
% available for selection, along with their corresponding frequency are as
% follows:
% 
%     Murderer:
%         Colonel Mustard (8Hz)
%         Miss Scarlett (10Hz)
%         Professor Plum (12Hz)
%         Reverend Green (15Hz)
% 
%     Weapon:
%         Axe (8Hz)
%         Poison (10Hz)
%         Revolver (12Hz)
%         Rope (15Hz)
% 
%     Location:
%         Billiard Room (8Hz)
%         Dining Room (10Hz)
%         Kitchen (12Hz)
%         Library (15Hz)
%%
% The data is located on my public dropbox account. Again, running the code
% below will download the data, which will take some time depending on the
% speed of your internet connection.
%
% *NOTE:* The data used in this tutorial is EEG data that has been bandpass
% filtered with a 3rd order Butterworth filter with a passband of 1.0-40
% Hz. When performing analysis on other data, you might have to filter it
% yourself. Bandpass filtering is covered in the 3rd tutorial.
urlwrite('http://dl.dropbox.com/u/79303435/tutorial2-01.mat?dl=1', 'tutorial2-01.mat');
%%
% Using |load| to load the Matlab file and printing the variables stored
% within:
m = load('tutorial2-01.mat');
disp('Fields of m:');
disp(fields(m));
%%
% The three variables of interest are |Murder_filteredEEG|,
% |Weapon_filteredEEG| and |Room_filteredEEG|
murder_EEG = m.Murder_filteredEEG;
weapon_EEG = m.Weapon_filteredEEG;
room_EEG = m.Room_filteredEEG;

disp('Shape of murder_EEG:'); disp(size(murder_EEG));
disp('Shape of weapon_EEG:'); disp(size(weapon_EEG));
disp('Shape of room_EEG:'); disp(size(room_EEG));
%%
% The data was recorded using the <http://www.emotiv.com Emotiv EPOC>
% device. It has 14 channels and a sample rate of 128Hz:
nchannels = size(murder_EEG, 1);
nsamples = size(murder_EEG, 2);
sample_rate = 128;

fprintf('Duration of recordings: %.1f seconds\n', nsamples / sample_rate);
%%
% The subject was looking for 20 seconds at one of the four selection
% options. If we plot the PSD (power spectral density) of the channels on
% the visual cortex, there should be a distinctive peak at the frequency of
% the attended option. The algorithm to calculate a PSD is provided by the
% function |pwelch|:
help pwelch;
%%
% Below is some code that calculates the PSD for some channels of the
% murderer EEG block:

% These channels are roughly in the area covering the visual cortex
channels_of_interest = [1, 2, 3, 12, 13, 14];

% Create a new figure
figure('Position', [100, 100, 1000, 500]);

% Draw the PSD of each channel of interest
for i = 1:length(channels_of_interest)
    ch = channels_of_interest(i);
    
    % The main plot is devided into 6 subplots: one for each channel
    % They are layed out in a grid: 2 rows and 3 columns
    subplot(2, 3, i);
    
    % Calculate the PSD
    [murder_PSD, freqs] = pwelch(murder_EEG(ch,:), nsamples, [], [], sample_rate);

    % Plot the PSD
    plot(freqs, murder_PSD);
    
    % Each graph should have the same scale, otherwise we cannot compare them
    xlim([0, 40]);
    ylim([0, 60]);

    % Add some decoration
    grid();
    xlabel('Frequency (Hz)');
    ylabel('PSD (dB)');
    title(sprintf('Channel %d', ch));
end
%%
% The EEG recording made by the Emotiv EPOC is noisy: there are many peaks.
% Still, the peak at 10Hz is strongest as can be observed at channels 1 and
% 14. Therefore the conclusion is that the murderer is Miss Scarlett.
%% Automatic classification
% A common approach to automatically determine the frequency that is
% present most strongly is
% <http://en.wikipedia.org/wiki/Canonical_correlation Canonical Correlation
% Analysis (CCA)> [1]. The idea is that an EEG recording of someone looking
% at a SSVEP stimulus with frequency $f$, will be highly correlated with a
% generated sine wave with the same frequency. More so than a generated
% sine wave with a different frequency. Under the condition that the EEG
% signal and the generated sine are in phase (e.g. the waveforms 'line
% up'). This condition is problematic, as we have no guarantee that this
% will be the case. To counter the phase shift, we correlate the EEG signal
% with both a sine and a cosine wave, following the same logic employed by
% the Fourier transform. If the sine wave correlates poorly, the cosine
% will correlate strongly and vice versa, as long as the frequencies match.
% 
% Simple correlation analysis only compares two vectors, lets call them $x$
% and $y$. For example a single EEG channel and an artificial signal of the
% same length. In our case we have multiple EEG channels, so vector $x$
% becomes a matrix $X$ with samples along the rows and channels in the
% columns. We are testing this signal against multiple sine and cosine
% waves, generated with frequence $f$ and also some harmonics of $f$ ($2f$
% and $3f$ in this case). So $y$ becomes a matrix $Y$ with the generated
% samples in the rows and each column containing either a sine or cosine
% generated with some frequency.
% 
% The CCA procedure can be seen as a way to calculate the correlation
% between two sets of vectors simultaniously, a set of vectors being the
% same as a matrix. It does so be calculating a vector $u_0$, which is a
% linear combination of the columns of $X$ and a vector $v_0$, which is a
% linear combination of the columns of $Y$, in such a way that the
% correlation coefficient $\rho$ between $u_0$ and $v_0$ is maximal. It then
% goes on to calculate more vectors $u_1$ and $v_1$ that are uncorrelated
% with $u_0$ and $v_0$ and maximally correlated with each other. In our
% case however, we are only interested in the correlation between $u_0$ and
% $v_0$.
% 
% The task of our classifier is what we did manually before: to pick, out
% of the frequencies of all the stimuli on the screen, the one that best
% corresponds to what is present in the EEG signal. Therefore, for each
% frequency, we calculate a score for that frequency by performing CCA
% between the EEG signal and a matrix of generated sine/cosine waves with
% the frequency and its harmonics. Finally we pick the frequency with the
% highest score.
% 
% [1] Frequency recognition based on canonical correlation analysis for
% SSVEP-based BCIs. Lin, Zhonglin / Zhang, Changshui / Wu, Wei / Gao,
% Xiaorong, _IEEE transactions on bio-medical engineering_, 53 (12 Pt 2),
% p.2610-2614, Dec 2006, http://www.ncbi.nlm.nih.gov/pubmed/17152442
% 
% The CCA algorithm is provided by the matlab |canoncorr| function:
help canoncorr;
%%
% Below is a function that implements the classifier:
function winner = ssvep_classifier(EEG, frequencies)    
%     SSVEP classifier based on Canonical Correlation Analysis (CCA).
%     Given a list of frequencies, this function will return the frequency
%     that is present the most strongly in some given EEG signal.

    % The matrix X is our EEG signal, but we transpose it so
    % observations (=samples) are on the rows and variables (=channels)
    % are on the columns.
    X = EEG';

    % Keep track of the score for each frequency
    scores = [];
    
    % Calculate a timeline in seconds, so we can construct
    % sine/cosine waves with the correct frequencies
    time = (1:nsamples) / sample_rate;
    
    % Calculate sines/cosines for all possible frequencies 
    for frequency = frequencies
        
        % Calculate this part only once
        y = 2 * pi * frequency * time;
    
        % Construct the matrix Y containing the base frequency and 2 harmonics
        Y = [sin(y); cos(y); sin(2*y); cos(2*y); sin(3*y); cos(3*y)]';
    
        % Perform canonical correlation, we only care about the
        % coefficients:
        [~, ~, R] = canoncorr(X,Y);
            
        % Note the highest (= first) coefficient as the final score for
        % this frequency
        scores = [scores R(1)];
    end
    
    % Return the frequency with the highest score
    [~, winner_index] = max(scores);
    winner = frequencies(winner_index);
end
%%
% Putting the classifier to work, lets solve the murder completely:
fprintf('Murderer frequency: %d Hz.\n', ssvep_classifier(murder_EEG, [8, 10, 12, 15]));
fprintf('Weapon frequency:   %d Hz.\n', ssvep_classifier(weapon_EEG, [8, 10, 12, 15]));
fprintf('Room: frequency:    %d Hz.\n', ssvep_classifier(room_EEG, [8, 10, 12, 15]));
%%
% Looking at the table at the beginning of this tutorial, this means Miss
% Scarlett was the murderer, using a rope in the kitchen.
end
##### SOURCE END #####
--></body></html>